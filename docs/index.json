[
{
	"uri": "https://efficienthacks.github.io/coderbook/powershelltips/",
	"title": "PowerShell Tips and Quirks",
	"tags": [],
	"description": "",
	"content": " reserved variable names Do not use these as variable names - PowerShell will not complain if you do, you\u0026rsquo;ll just see weird results (variable names are case insensitive)\n$input $home  "
},
{
	"uri": "https://efficienthacks.github.io/coderbook/01dotnet-intermediatetopics/01async-await/",
	"title": "async and await",
	"tags": [],
	"description": "",
	"content": " tldr async and await are keywords in C# to let code continue executing while waiting on a long operation (like downloading a file) to complete.\nTypically, I write synchronous code because it is easier to debug, after it works, then I\u0026rsquo;ll use async/await.\nTo make async methods synchronous (i.e. block further code execution until method finishes), add .Result to the end of the method call. E.g. client.DownloadFileAsync().Result\nQuick code snippet This is how you create a batch of web requests to run in parallel. (You await on Task.WhenAll() instead of awaiting after each call to DownloadWebsiteAsync())\npublic async Task RunDownloadParallelAsync() { List\u0026lt;string\u0026gt; websites = GetWebsiteList(); var tasks = new List\u0026lt;Task\u0026lt;DownloadWebsiteResult\u0026gt;\u0026gt;(); foreach (string site in websites) { tasks.Add(DownloadWebsiteAsync(site)); } List\u0026lt;DownloadWebsiteResult\u0026gt; results = await Task.WhenAll(tasks); foreach (DownloadWebsiteResult dwr in results) { ReportWebsiteInfo(dwr); } }   Code snippet is part of the example used in the following video.  Video This video does a great job at explaining async and await. Tim goes through the example of downloading a sequence of files. (Watch it in double speed):\n  Here\u0026rsquo;s how to cancel tasks and get progress on the task\n  "
},
{
	"uri": "https://efficienthacks.github.io/coderbook/01dotnet-intermediatetopics/02dyanamic-types/",
	"title": "Ignoring Types",
	"tags": [],
	"description": "",
	"content": " Strongly typed vs weakly typed Strongly typed means that the compiler will complain if a method does not exist in the class specified during variable declaration.\nAnimal duck = Factory.MakeDuck(); duck.quack(); //compile error because quack() is not defined in Animal even though you know the underlying object is a duck  Weakly typed means that the compiler will not care whether the method exists or not (it will be done at runtime)\ndynamic duck = Factory.MakeDuck(); duck.quack(); //a method called \u0026quot;quack()\u0026quot; will be checked at runtime. Also, the autocomplete will not work for dynamic variables.  There may be cases where you will need to ignore the object type in order to make classes decoupled. It\u0026rsquo;s highly recommended that you have unit tests that will catch type errors.\nI typically use dynamic when parsing JSON data with arbitrary/unknown fields.\nType checking Here\u0026rsquo;s how you check whether an object is of a certain type\nif(someObject is Duck d) //shorthand for typecasting someObject to \u0026quot;Duck\u0026quot; within the if block { d.quack(); }  "
},
{
	"uri": "https://efficienthacks.github.io/coderbook/01dotnet-intermediatetopics/03calling-privatemethods/",
	"title": "Calling Private Methods",
	"tags": [],
	"description": "",
	"content": " Intro to reflection "
},
{
	"uri": "https://efficienthacks.github.io/coderbook/psmodules/",
	"title": "Creating Modules",
	"tags": [],
	"description": "",
	"content": " There are Script modules (.psm1 files) and Binary modules (aka cmdlets)\nScript Module A script module is essentially any valid PowerShell script saved in a .psm1 extension.\nfunction Show-Calendar { } Export-ModuleMember -Function Show-Calendar  The paths where you can install your module are located in the $env:PSModulePath global variable. Be sure to create a folder for your module to exist in, even if it is only a single .psm1 file\nBy default, all functions in your script are accessible to users who import your .psm1 file, but properties are not.\nBinary (C#) Module Make a class library (dll)\nYou have to import the module by dll name: Import-Module BinModuleTest\\PSbinModule.dll\nusing System.Management.Automation; // Windows PowerShell namespace. namespace ModuleCmdlets { [Cmdlet(VerbsDiagnostic.Test, \u0026quot;BinaryModuleCmdlet1\u0026quot;)] public class TestBinaryModuleCmdlet1Command : Cmdlet { protected override void BeginProcessing() { WriteObject(\u0026quot;BinaryModuleCmdlet1 exported by the ModuleCmdlets module.\u0026quot;); } } [Cmdlet(VerbsDiagnostic.Test, \u0026quot;BinaryModuleCmdlet2\u0026quot;)] public class TestBinaryModuleCmdlet2Command : Cmdlet { protected override void BeginProcessing() { WriteObject(\u0026quot;BinaryModuleCmdlet2 exported by the ModuleCmdlets module.\u0026quot;); } } [Cmdlet(VerbsDiagnostic.Test, \u0026quot;BinaryModuleCmdlet3\u0026quot;)] public class TestBinaryModuleCmdlet3Command : Cmdlet { protected override void BeginProcessing() { WriteObject(\u0026quot;BinaryModuleCmdlet3 exported by the ModuleCmdlets module.\u0026quot;); } } }  You invoke the cmdlet like this: \u0026ldquo;Test-BinaryModuleCmdlet1\u0026rdquo;\nDebugging Binary PS Modules If you\u0026rsquo;re using Visual Studio (and making a .NET Framework library), right click on the csproj and add this to the Debug command line args: -noexit -command \u0026quot;\u0026amp;{ import-module .\\[dllName].dll -verbose}\u0026quot;\nReference: https://www.powershellmagazine.com/2014/04/08/basics-of-writing-a-powershell-module-with-c-part-2-debugging/\nIf you are making a .NET Standard library, you\u0026rsquo;ll have to add a post build event: add dotnet publish --no-build to the post build event and change the command line argument to reference .\\publish\\[dllName].dll\nThe post build event copies all the dlls (in nuget packages) that you reference (like json.net) into the output folder.\nOriginal stackoverflow answer\n"
},
{
	"uri": "https://efficienthacks.github.io/coderbook/powershell/pipinginput/",
	"title": "Piping input",
	"tags": [],
	"description": "",
	"content": " So how do take input (which is usually an array of objects) that is passed to your module?\nUsing powershell You just add an attribute to the parameter.\nfunction show-data { param( [Parameter(ValueFromPipeline=$true)] $InputObject ) begin { $objects = @() } process { $objects += $InputObject } end { foreach($obj in $objects) { $obj #$obj is written to the pipeline on each iteration of the loop } } } Get-ChildItem | show-data  Note that process is called for each item in the array. In the code snippet, we collected all the items to be processed during end\nUsing C# module In C# code, this is what it looks like:\nusing System.Management.Automation; //get this from nuget package manager - use PowerShellStandard.Library [Cmdlet(VerbsDiagnostic.Test, \u0026quot;PipelineObjDyn\u0026quot;)] public class TestPipelineDynamic : Cmdlet { [Parameter(ValueFromPipeline = true)] public dynamic ObjectFromPipeline { get; set; } //using dynamic because we don't know what type is going to be returned; using PSObject would be better. private List\u0026lt;dynamic\u0026gt; objects; protected override void BeginProcessing() { objects = new List\u0026lt;dynamic\u0026gt;(); } protected override void ProcessRecord() { objects.Add(ObjectFromPipeline); } protected override void EndProcessing() { foreach (var obj in objects) { WriteObject(obj); //writes object to the pipeline } } }  I strongly recommend using Visual Studio to set breakpoints and see what the underlying object (ObjectFromPipeline) looks like. You\u0026rsquo;ll get a much better understanding of what\u0026rsquo;s going on.\nCmdlet development tips When developing cmdlets (binary PS modules), you will want to convert PSObject to/from Dictionary\u0026lt;string,object\u0026gt; (or ExpandoObject)\npublic static class HelperExtensions { public static PSObject AsPSObject(this ExpandoObject eo) { //makes it so that your C# objects can be filtered/manipulated with powershell syntax var newpso = new PSObject(); var expandoAsDict = ((IDictionary\u0026lt;string, object\u0026gt;)eo); foreach (var k in expandoAsDict.Keys) { newpso.Members.Add(new PSNoteProperty(k, expandoAsDict[k])); } return newpso; } public static IDictionary\u0026lt;string,object\u0026gt; AsDictionary(this PSObject pso) { //makes stuff coming in from the pipeline easier to handle var newDict = new Dictionary\u0026lt;string, object\u0026gt;(); foreach (var prop in pso.Properties) { newDict[prop.Name] = prop.Value; } return newDict; } }  Example Cmdlet Code Example cmdlet that reads a csv file and outputs results as an array of PSObjects\n[Cmdlet(VerbsDiagnostic.Test, \u0026quot;WriteObject\u0026quot;)] public class TestBinaryModuleCmdlet1Command : Cmdlet { protected override void BeginProcessing() { using (var reader = new StreamReader(@\u0026quot;D:\\temp\\test.csv\u0026quot;)) { using (var csv = new CsvReader(reader)) { var records = csv.GetRecords\u0026lt;dynamic\u0026gt;(); foreach(var rec in records) { WriteObject(((ExpandoObject)rec).AsPSObject()); } } } } }  CsvReader is part of the CsvHelper nuget package\n"
},
{
	"uri": "https://efficienthacks.github.io/coderbook/01dotnet-intermediatetopics/",
	"title": ".NET Intermediate Topics",
	"tags": [],
	"description": "",
	"content": " A guide to .NET for people who already know the basics FAQs .NET Standard vs .NET Core vs .NET Framework? Target .NET Core for executables that can be deployed on linux, mac + Windows.\nTarget .NET Framework if you\u0026rsquo;re in a Windows-only environment or need to use Windows-specific functionality (like the UI, or Active Directory)\nWhere possible, target .NET Standard for common code libraries (can be used by both .NET Core and Framework)\n"
},
{
	"uri": "https://efficienthacks.github.io/coderbook/02powershell/",
	"title": "Powershell",
	"tags": [],
	"description": "",
	"content": " A guide to PowerShell for people who already know the basics FAQs PowerShell Core? Windows PowerShell? As of 2019, PowerShell Core (aka PowerShell 6) is missing a lot of features (especially for AD and Exchange management). It is a separate install and it\u0026rsquo;s named pwsh.exe. It uses .NET Core.\nWindows PowerShell is the original - found in C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe it comes with Windows and has version 1.0 to 5.1. It is using the .NET Framework.\nPowershell modules written in .NET Standard will work on both.\n"
},
{
	"uri": "https://efficienthacks.github.io/coderbook/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "asdf\n"
},
{
	"uri": "https://efficienthacks.github.io/coderbook/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://efficienthacks.github.io/coderbook/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]